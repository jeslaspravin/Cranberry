#include "{{HeaderInclude}}"
#include "Property/ContainerProperty.h"
#include "Types/CoreMiscDefines.h"

/* Generated codes do not modify here */
    
#ifdef HEADER_FILE_ID
#undef HEADER_FILE_ID
#endif

#define HEADER_FILE_ID {{HeaderFileId}}

struct HEADER_FILE_ID
{
    using ThisType = HEADER_FILE_ID;
    HEADER_FILE_ID();
    
    {{#AllRegisterTypes}}
    static {{PropertyTypeName}}* create_{{SanitizedName}}();{{^NoInit}}
    static void init_{{SanitizedName}}({{PropertyTypeName}}* typeProperty);{{/NoInit}}
    {{/AllRegisterTypes}}
    
    {{#Classes}}{{^IsAbstract}}
    template <typename... Args>
    static {{TypeName}}* {{SanitizedName}}_CTor(Args&&... args);{{/IsAbstract}}{{/Classes}}
} COMBINE(HEADER_FILE_ID, _autoinit);

HEADER_FILE_ID::HEADER_FILE_ID()
{
    {{#AllRegisterTypes}}
    IReflectionRuntimeModule::{{RegisterFunctionName}}(TCHAR("{{TypeName}}"), typeInfoFrom<{{TypeName}}>()
        , { &ThisType::create_{{SanitizedName}}{{^NoInit}}, &ThisType::init_{{SanitizedName}}{{/NoInit}} }
    );
    {{/AllRegisterTypes}}
}

{{#QualifiedTypes}}
BaseProperty* HEADER_FILE_ID::create_{{SanitizedName}}()
{
    return new QualifiedProperty(TCHAR("{{TypeName}}"), typeInfoFrom<{{TypeName}}>());
}
void HEADER_FILE_ID::init_{{SanitizedName}}(BaseProperty* typeProperty)
{
    QualifiedProperty* prop = static_cast<QualifiedProperty*>(typeProperty);
    prop->setUnqualifiedType(IReflectionRuntimeModule::getType<CleanType<{{TypeName}}>>());
}
{{/QualifiedTypes}}

{{#PairTypes}}
BaseProperty* HEADER_FILE_ID::create_{{SanitizedName}}()
{
    return new PairProperty(TCHAR("{{TypeName}}"), typeInfoFrom<{{TypeName}}>());
}
void HEADER_FILE_ID::init_{{SanitizedName}}(BaseProperty* typeProperty)
{
    PairProperty* prop = static_cast<PairProperty*>(typeProperty);
    prop->setFirstProperty(IReflectionRuntimeModule::getType<{{TypeName}}::first_type>());
    prop->setSecondProperty(IReflectionRuntimeModule::getType<{{TypeName}}::second_type>());
    prop->constructDataRetriever<PairDataRetrieverImpl<{{TypeName}}::first_type, {{TypeName}}::second_type>>();
}
{{/PairTypes}}

{{#ContainerTypes}}
BaseProperty* HEADER_FILE_ID::create_{{SanitizedName}}()
{
    return new ContainerPropertyImpl<{{TypeName}}>(TCHAR("{{TypeName}}"), typeInfoFrom<{{TypeName}}>());
}
void HEADER_FILE_ID::init_{{SanitizedName}}(BaseProperty* typeProperty)
{
    ContainerPropertyImpl<{{TypeName}}>* prop = static_cast<ContainerPropertyImpl<{{TypeName}}>*>(typeProperty);
    prop->setElementProperty(IReflectionRuntimeModule::getType<{{TypeName}}::value_type>());
    prop->constructDataRetriever<ContainerRetrieverImpl<{{TypeName}}>>();
}
{{/ContainerTypes}}

{{#MapTypes}}
BaseProperty* HEADER_FILE_ID::create_{{SanitizedName}}()
{
    return new MapProperty(TCHAR("{{TypeName}}"), typeInfoFrom<{{TypeName}}>());
}
void HEADER_FILE_ID::init_{{SanitizedName}}(BaseProperty* typeProperty)
{
    MapProperty* prop = static_cast<MapProperty*>(typeProperty);
    prop->setElementProperty(IReflectionRuntimeModule::getType<{{TypeName}}::value_type>());
    prop->setKeyProperty(IReflectionRuntimeModule::getType<{{TypeName}}::key_type>());
    prop->setValueProperty(IReflectionRuntimeModule::getType<{{TypeName}}::mapped_type>());
    prop->constructDataRetriever<MapDataRetrieverImpl<{{TypeName}}>>();
}
{{/MapTypes}}

{{#EnumTypes}}
EnumProperty* HEADER_FILE_ID::create_{{SanitizedName}}()
{
    return new EnumProperty(TCHAR("{{TypeName}}"), typeInfoFrom<{{TypeName}}>(), {{CanUseAsFlags}});
}
void HEADER_FILE_ID::init_{{SanitizedName}}(EnumProperty* typeProperty)
{
    typeProperty->setPropertyMetaData({ {{TypeMetaData}} }, {{TypeMetaFlags}});
{{!Now the Enum's section context contains context for enum fields}}
{{#EnumFields}}    typeProperty->addEnumField(TCHAR("{{EnumFieldName}}"), {{EnumFieldValue}}, {{EnumFieldMetaFlags}}, { {{EnumFieldMetaData}} });
{{/EnumFields}}    
}
{{/EnumTypes}}

{{#Classes}}{{^IsAbstract}}
template <typename... Args>
static {{TypeName}}* HEADER_FILE_ID::{{SanitizedName}}_CTor(Args&&... args)
{
    return new {{TypeName}}(std::forward<Args>(args)...);
}{{/IsAbstract}}

ClassProperty* HEADER_FILE_ID::create_{{SanitizedName}}()
{
    return new ClassProperty(TCHAR("{{TypeName}}"), typeInfoFrom<{{TypeName}}>());
}
void HEADER_FILE_ID::init_{{SanitizedName}}(ClassProperty* typeProperty)
{
    typeProperty->setPropertyMetaData({ {{TypeMetaData}} }, {{TypeMetaFlags}});
{{!Now the Class's section context contains context for class fields}}
{{#BaseClasses}}
    typeProperty->addBaseClass(IReflectionRuntimeModule::getType<{{BaseClassTypeName}}>());{{/BaseClasses}}
{{^IsAbstract}}{{#Ctors}}
    typeProperty->addCtorPtr()
                ->setFieldAccessor(EPropertyAccessSpecifier::{{AccessSpecifier}}){{#ParamsListContext}}
                ->addFunctionParamProperty(TCHAR("{{ParamName}}"), IReflectionRuntimeModule::getType<{{ParamTypeName}}>()){{/ParamsListContext}}
                ->setFunctionReturnProperty(IReflectionRuntimeModule::getType<{{TypeName}}*>())
                ->setPropertyMetaData({ {{CtorMetaData}} }, {{CtorMetaFlags}})
                ->constructFuncPointer<GlobalFunctionWrapperImpl<{{TypeName}}*, {{ParamsList}}>>(&ThisType::{{SanitizedName}}_CTor<{{ParamsList}}>);
{{/Ctors}}{{^Ctors}}{{!If no ctors then just create default ctor}}
    typeProperty->addCtorPtr()
                ->setFieldAccessor(EPropertyAccessSpecifier::Public)
                ->setFunctionReturnProperty(IReflectionRuntimeModule::getType<{{TypeName}}*>())
                ->constructFuncPointer<GlobalFunctionWrapperImpl<{{TypeName}}*>>(&ThisType::{{SanitizedName}}_CTor<>);
{{/Ctors}}{{/IsAbstract}}{{#MemberFuncs}}
    typeProperty->addMemberFunc(TCHAR("{{FunctionName}}"))
                ->setFieldAccessor(EPropertyAccessSpecifier::{{AccessSpecifier}}){{#ParamsListContext}}
                ->addFunctionParamProperty(TCHAR("{{ParamName}}"), IReflectionRuntimeModule::getType<{{ParamTypeName}}>()){{/ParamsListContext}}
                ->setFunctionReturnProperty(IReflectionRuntimeModule::getType<{{ReturnTypeName}}>())
                ->setPropertyMetaData({ {{FuncMetaData}} }, {{FuncMetaFlags}})
                ->constructFuncPointer<MemberFunctionWrapperImpl<{{#FuncConst}}const {{/FuncConst}}{{TypeName}}, {{ReturnTypeName}}, {{ParamsList}}>>(&{{TypeName}}::{{FunctionName}});
{{/MemberFuncs}}{{#StaticFuncs}}
    typeProperty->addStaticFunc(TCHAR("{{FunctionName}}"))
                ->setFieldAccessor(EPropertyAccessSpecifier::{{AccessSpecifier}}){{#ParamsListContext}}
                ->addFunctionParamProperty(TCHAR("{{ParamName}}"), IReflectionRuntimeModule::getType<{{ParamTypeName}}>()){{/ParamsListContext}}
                ->setFunctionReturnProperty(IReflectionRuntimeModule::getType<{{ReturnTypeName}}>())
                ->setPropertyMetaData({ {{FuncMetaData}} }, {{FuncMetaFlags}})
                ->constructFuncPointer<GlobalFunctionWrapperImpl<{{ReturnTypeName}}, {{ParamsList}}>>(&{{TypeName}}::{{FunctionName}});
{{/StaticFuncs}}
{{#MemberFields}}
    typeProperty->addMemberField(TCHAR("{{FieldName}}"))
                ->setFieldAccessor(EPropertyAccessSpecifier::{{AccessSpecifier}})
                ->setField(IReflectionRuntimeModule::getType<{{FieldTypeName}}>())
                ->setPropertyMetaData({ {{FieldMetaData}} }, {{FieldMetaFlags}})
                ->constructFieldPtr<MemberFieldWrapperImpl<{{TypeName}}, {{FieldTypeName}}>>(&{{TypeName}}::{{FieldName}});
{{/MemberFields}}{{#StaticFields}}
    typeProperty->addStaticField(TCHAR("{{FieldName}}"))
                ->setFieldAccessor(EPropertyAccessSpecifier::{{AccessSpecifier}})
                ->setField(IReflectionRuntimeModule::getType<{{FieldTypeName}}>())
                ->setPropertyMetaData({ {{FieldMetaData}} }, {{FieldMetaFlags}})
                ->constructFieldPtr<GlobalFieldWrapperImpl<{{FieldTypeName}}>>(&{{TypeName}}::{{FieldName}});
{{/StaticFields}}
}
{{/Classes}}